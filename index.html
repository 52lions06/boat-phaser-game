<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Load the Socket.io networking library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Multiplayer BattleShip!</title>
    <!-- <link rel="stylesheet" href="boat-tutorial/main.css"> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/2.4.2/phaser.min.js"></script>
</head>

<body>
    <!-- <script src="boat-tutorial/server.js"></script> -->
    <script>
        console.log('heyo')

        let ASSET_URL = "https://cdn.glitch.com/d371c629-b475-4d7b-88bc-b2558ae406a4%2F"

        let WINDOW_WIDTH = 750;
        let WINDOW_HEIGHT = 500;
        let game = new Phaser.Game(WINDOW_WIDTH, WINDOW_HEIGHT, Phaser.AUTO, '', { preload: preload, create: create, update: GameLoop })

        let WORLD_SIZE = { w: 750, h: 500 };

        let water_tiles = [];
        let bullet_array = [];
        let other_players = {};
        let socket;

        let player = {
            sprite: null,
            speed_x: 0,
            speed_y: 0,
            speed: 0.5,
            friction: 0.95,
            shot: false,
            update: function () {
                let dx = (game.input.mousePointer.x + game.camera.x) - this.sprite.x;
                let dy = (game.input.mousePointer.y + game.camera.y) - this.sprite.y;
                let angle = Math.atan2(dy, dx) - Math.PI / 2;
                let dir = (angle - this.sprite.rotation) / (Math.PI * 2);
                dir -= Math.round(dir);
                dir = dir * Math.PI * 2;
                this.sprite.rotation += dir * 0.1;

                //Forward movement
                if (game.input.keyboard.isDown(Phaser.Keyboard.W) || game.input.keyboard.isDown(Phaser.Keyboard.UP)) {
                    this.speed_x += Math.cos(this.sprite.rotation + Math.PI / 2) * this.speed;
                    this.speed_y += Math.sin(this.sprite.rotation + Math.PI / 2) * this.speed;
                }

                this.sprite.x += this.speed_x;
                this.sprite.y += this.speed_y;

                this.speed_x *= this.friction;
                this.speed_y *= this.friction;

                //Shoot bullet
                if (game.input.activePointer.leftButton.isDown && !this.shot) {
                    var speed_x = Math.cos(this.sprite.rotation + Math.PI / 2) * 20;
                    var speed_y = Math.sin(this.sprite.rotation + Math.PI / 2) * 20;
                    /* The server is now simulating the bullets, clients are just rendering bullet locations, so no need to do this anymore
                    var bullet = {};
                    bullet.speed_x = speed_x;
                    bullet.speed_y = speed_y;
                    bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,'bullet');
                    bullet_array.push(bullet); 
                    */
                    this.shot = true;
                    // Tell the server we shot a bullet 
                    socket.emit('shoot-bullet', { x: this.sprite.x, y: this.sprite.y, angle: this.sprite.rotation, speed_x: speed_x, speed_y: speed_y })
                }
                if (!game.input.activePointer.leftButton.isDown) {
                    this.shot = false;
                }
                        if (this.sprite.alpha < 1) {
                            this.sprite.alpha += (1 - this.sprite.alpha) * 0.16;
                        } else {
                            this.sprite.alpha = 1;
                        }
                socket.emit('move-player',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation})
            }

        }

        function createShip(type, x, y, angle) {
            let sprite = game.add.sprite(x, y, 'ship' + String(type) + '_1')
            sprite.rotation = angle;
            sprite.anchor.setTo(0.5, 0.5);
            console.log(sprite, 'spritelicious')
            return sprite;
        }

        function preload() {
            game.load.crossOrigin = "Anonymous";
            game.stage.backgroundColor = "#3399DA";

            for (let i = 1; i <= 6; i++) {
                game.load.image('ship' + String(i) + '_1', ASSET_URL + 'ship' + String(i) + '_1.png')
                game.load.image('ship' + String(i) + '_2', ASSET_URL + 'ship' + String(i) + '_2.png')
                game.load.image('ship' + String(i) + '_3', ASSET_URL + 'ship' + String(i) + '_3.png')
                game.load.image('ship' + String(i) + '_4', ASSET_URL + 'ship' + String(i) + '_4.png')
            }

            game.load.image('bullet', ASSET_URL + 'cannon_ball.png');
            game.load.image('water', ASSET_URL + 'water_tile.png')
        }

        function create() {

            //create water tiles
            for (let i = 0; i <= WORLD_SIZE.w / 64 + 1; i++) {
                for (let j = 0; j <= WORLD_SIZE.h / 64 + 1; j++) {
                    let tile_sprite = game.add.sprite(i * 64, j * 64, 'water')
                    tile_sprite.anchor.setTo(0.5, 0.5);
                    tile_sprite.alpha = 0.5;
                    water_tiles.push(tile_sprite)
                }
            }
            game.stage.disableVisibilityChange = true;

            
            //create player
            let player_ship_type = String(1);
            player.sprite = game.add.sprite(Math.random() *
                WORLD_SIZE.w / 2 + WORLD_SIZE.w / 2, Math.random() *
                WORLD_SIZE.h / 2 + WORLD_SIZE.h / 2,
                'ship' + player_ship_type + '_1')
            player.sprite.anchor.setTo(0.5, 0.5);
            game.world.setBounds(0, 0, WORLD_SIZE.w, WORLD_SIZE.h);
            
            socket = io();
            socket.emit('new-player', {
                x: player.sprite.x,
                y: player.sprite.y,
                angle: player.sprite.rotation,
                type: 1
            })

            socket.on('update-players', function (players_data) {
                let players_found = {};
                for (let id in players_data) {
                    if (other_players[id] == undefined && id != socket.id) {
                        let data = players_data[id];
                        let p = createShip(data.type, data.x, data.y, data.angle);
                        other_players[id] = p;
                        console.log('Created new player at (' + data.x + ', ' + data.y + ')')
                    }
                    players_found[id] = true;
                    // console.log(players_found[id])
                    if (id != socket.id) {
                        other_players[id].target_x = players_data[id].x;
                        other_players[id].target_y = players_data[id].y;
                        other_players[id].target_rotation = players_data[id].angle;
                    }
                }
                for (let id in other_players) {
                    if (!players_found[id]) {
                        other_players[id].destroy();
                        delete other_players[id]
                    }
                }
            })

            // socket.on('create-player', function (state) {
            //     console.log('woohoo new one')
            //     createShip(1, state.x, state.y, state.angle)
            // })

            

          
            // Listen for bullet update events 
            socket.on('bullets-update', function (server_bullet_array) {
                // If there's not enough bullets on the client, create them
                for (var i = 0; i < server_bullet_array.length; i++) {
                    if (bullet_array[i] == undefined) {
                        bullet_array[i] = game.add.sprite(server_bullet_array[i].x, server_bullet_array[i].y, 'bullet');
                    } else {
                        //Otherwise, just update it! 
                        bullet_array[i].x = server_bullet_array[i].x;
                        bullet_array[i].y = server_bullet_array[i].y;
                    }
                }
                // Otherwise if there's too many, delete the extra 
                for (var i = server_bullet_array.length; i < bullet_array.length; i++) {
                    bullet_array[i].destroy();
                    bullet_array.splice(i, 1);
                    i--;
                }

            })

            // Listen for any player hit events and make that player flash 
            socket.on('player-hit', function (id) {
                if (id == socket.id) {
                    //If this is you
                    console.log('hit')
                    player.sprite.alpha = 0;
                } else {
                    console.log('not hit')
                    // Find the right player 
                    other_players[id].alpha = 0;
                }
            })

            //keeps player in the center?
            game.camera.x = player.sprite.x - WINDOW_WIDTH / 2;
            game.camera.y = player.sprite.y - WINDOW_HEIGHT / 2;
        }

        function GameLoop() {
            player.update();

            let camera_x = player.sprite.x - WINDOW_WIDTH / 2;
            let camera_y = player.sprite.y - WINDOW_HEIGHT / 2;
            game.camera.x += (camera_x - game.camera.x) * 0.08;
            game.camera.y += (camera_y - game.camera.y) * 0.08;

            // Interpolate all players to where they should be 
                        for(var id in other_players){
                          
                                if(other_players[id].alpha < 1){
                                    other_players[id].alpha += (1 - other_players[id].alpha) * 0.16;
                                } else {
                            
                                    other_players[id].alpha = 1;
                                }
                            }

            for (var id in other_players) {
                var p = other_players[id];
                if (p.target_x != undefined) {
                    p.x += (p.target_x - p.x) * 0.16;
                    p.y += (p.target_y - p.y) * 0.16;
                    // Intepolate angle while avoiding the positive/negative issue 
                    var angle = p.target_rotation;
                    var dir = (angle - p.rotation) / (Math.PI * 2);
                    dir -= Math.round(dir);
                    dir = dir * Math.PI * 2;
                    p.rotation += dir * 0.16;
                }
            }
        }
    </script>

</body>

</html>